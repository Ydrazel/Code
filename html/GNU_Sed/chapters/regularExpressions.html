<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/1999/xhtml">
<html lang="en">
  <head>
    <meta type="text/html" charset="utf-8" />
    <link rel="stylesheet" href="../styles/main.css" />
    <title>Regular Expressions</title>
  </head>
  <body>
    <header>
      <h1 class="chapter_h">BRE/ERE Regular Expressions</h1>
    </header>
    <main id="main_content">
      <section id="introduction">
        <p>
          This chapter will cover Basic and Extended Regular Expressions as
          implemented in <code>GNU Sed</code>. Though not strictly conforming to
          <b>POSIX specifications</b>, most of it is applicable to other <code>
          sed</code> implementations as well. Unless otherwise indicated,
          examples and descriptions will assume ASCII input.
        </p>
        <p>
          By default, <code>sed</code> treats the search pattern as Basic Regular
          Expression (BRE). Using <code>-E</code> option will enable Extended
          Regular Expression (ERE). Older versions used <code>-r</code> for ERE,
          which can still be used, but <code>-E</code> is more portable. In <code>
          GNU sed</code>, BRE and ERE only differ in how metacharacters are applied,
          there's no difference in features.
        </p>
      </section>
      <section id="line_anchors">
        <h2 class="section_h">Line Anchors</h2>
        <p>
          Instead of matching anywhere in the line, restrictions can be specified.
          These restrictions are made possible by assigning special meaning to
          certain characters and escape sequences. The caharacters with special
          meaning are know as <b>metacharacters</b> in regular expressions parlance.
          In case you need to match those characters literally, you need to escape
          them with a <code>\</code> (discussed in <b>Matching the metacharacters</b>
          section).
        </p>
        <p>
          There are two line anchors:
        </p>
        <ul>
          <li><code>^</code> metacharacters restricts the matching to start of line</li>
          <li><code>$</code> metacharacters restricts the matching to end of line</li>
        </ul>
        <div class="code">
          <code>
            $ # lines starting with 'sp'<br />
            $ printf 'spared no one\npar\nspar\n' | sed -n '/^sp/p'<br />
            spared no one<br />
            spar<br />
            <br />
            $ # lines ending with 'ar'<br />
            $ printf 'spared no one\npar\nspar\n' | sed -n '/ar$/p'<br />
            par<br />
            spar<br />
            <br />
            $ # change only whole line 'par'<br />
            $ printf 'spared no one\npar\nspar\n' | sed 's/^par$/PAR/'<br />
            spared no one<br />
            PAR<br />
            spar
          </code>
        </div>
        <p>
          The anchors can be used by themselves as a pattern. Helps to insert
          text at start or end of line, emulating string concatenation operations.
          These might not feel like useful capability, but combined with other
          features they become quite a handy tool.
        </p>
        <div class="code">
          <code>
            $ printf 'spared no one\npar\nspar\n' | sed 's/^* /'<br />
            * spared no one<br />
            * par<br />
            * spar<br />
            <br />
            $ # append only if line doesn't contain space characters<br />
            $ printf ' spared no one\npar\nspar\n' | sed '/ /! s/$/./'<br />
            spared no one<br />
            par.<br />
            spar.
          </code>
        </div>
      </section>
      <section id="word_anchors">
        <h2 class="section_h">Word Anchors</h2>
        <p>
          The second type of restriction is word anchors. A word character is
          any alphabet (irrespective of case), digit and the underscore scharacter.
          You might wonder why there are digits and underscores as well, why not
          only alphabets? This comes from variable and function naming conventions
          -- typically alphabets, digits and underscore are allowed. So, the
          definition is more programming oriented than natural language.
        </p>
        <p>
          The sequence <code>\b</code> denotes a word boundary. This works for
          both start of word and end of word anchoring. Start of word means
          either the character prior to the word is a non-word character or
          there is no character (start of line). Similarly, end of word means
          the character after the word is a non-word character or no character
          (end of line). This implies that you cannot have boundary without a
          word character.
        </p>
        <div class="code">
          <code>
            $ cat word_anchors.txt<br />
            sub par<br />
            spar<br />
            apparent effort<br />
            two spare computers<br />
            cart part tart mart<br />
            <br />
            $ # words starting with 'par'<br />
            $ sed -n '/\bpar/p' word_anchors.txt<br />
            sub par<br />
            cart part tart mart<br />
            <br />
            $ # words ending with 'par'<br />
            $ sed -n '/par\b/p' wprd_anchors.txt<br />
            sub par<br />
            spar<br />
            <br />
            $ # only whole word 'par'<br />
            $ sed -n 's/\bpar\b/***/p' word_anchors.txt<br />
            sub ***
          </code>
        </div>
        <p>
          The word boundary has an opposite anchor too. <code>\B</code> matches
          wherever <code>\b</code> doesn't match. This duality will be seen with
          some other escape sequences too.
        </p>
        <div class="code">
          <code>
            $ # match 'par' if it is surrounded by word characters<br />
            $ sed -n '/\Bpar\B/p' word_anchors.txt<br />
            apparent effort<br />
            two spare computers<br />
            <br />
            $ # match 'par' but not as start of word<br />
            $ sed -n '/\Bpar/p' word_anchors.txt<br />
            spar<br />
            apparent effort<br />
            two spare computers<br />
            <br />
            $ # match 'par' but not as end of word<br />
            $ sed -n '/par\B/p' word_anchors.txt<br />
            apparent effort<br />
            two spare computers<br />
            cart part tart mart<br />
            <br />
            $ echo 'copper' | sed 's/\b/:/g'<br />
            :copper:<br />
            $ echo 'copper' | sed 's/\B/:/g'<br />
            c:o:p:p:e:r
          </code>
        </div>
      </section>
      <section id="alternation">
        <h2 class="section_h">Alternation</h2>
        <p>
          Many a times, you'd want to search for multiple terms. In a conditional
          expression, you can use the logical operators to combine multiple
          conditions. With regular expressions, the <code>|</code> metacharacter
          is similar to logical OR. The regular expression will match if any of
          the expression seperated by <code>|</code> is satisfied. These can have
          their own independent anchors as well.
        </p>
        <p>
          Alternation is similar to using multiple <code>-e</code> option, but
          provides more flexibility with regular expression features. The <code>
          |</code> metacharacter syntax varies between BRE and ERE. Quoting from
          the manual:
        </p>
        <div class="code">
          <code>
            $ # BRE vs ERE<br />
            $ sed -n '/two\|sub/p' word_anchors.txt<br />
            sub par<br />
            two spare computers<br />
            $ sed -nE '/two|sub/p' word_anchors.txt<br />
            sub par<br />
            two spare computers<br />
            <br />
            $ # either 'cat' or 'dog' or 'fox<br />
            $ # note the use of 'g' flag for multiple replacements<br />
            $ echo 'cats dog bee parrot foxed' | sed -E 's/cat|dog|fox/--/g'<br />
            --s -- be parrot --ed<br />
            <br />
            $ # lines with whole word 'par' or lines ending with 's'<br />
            $ sed -nE '/\bpar\b|s$/p' word_anchors.txt<br />
            sub par<br />
            two spare computers
          </code>
        </div>
        <p>
          There's some tricky situations when using alternation. If it is used
          for filtering a line, there is no ambiguity. However, for use cases
          like substitution, it depends on a few factors. Say, you want to
          replace <code>are</code> or <code>spared</code> -- which one should
          get precedence? The bigger word <code>spared</code> or the substring
          <code>are</code> inside it or based on something else?
        </p>
        <p>
          The alternative which matches earliest in the input gets precedence.
        </p>
        <div class="code">
          <code>
            $ # here, the output will be same irrespective of alternation order<br />
            $ # not that 'g' flag isn't used here, so only first match gets replaced<br />
            $ echo 'cats dog bee parrot foxed' | sed -E 's/bee|parrot|at/--/'<br />
            c--s dog bee parrot foxed<br />
            $ echo 'cats dog bee parrot foxed' | sed -E 's/parrot|at|bee/--/'<br />
            c--s dog bee parrot foxed
          </code>
        </div>
        <p>
          In case of matches starting from same location, for example <code>spar
          </code> and <code>spared</code>, the longest matching portion gets
          precedence. Unlike other regular expression implementations, left-to-right
          priority for alternation comes into play only if length of the matches
          are the same. See <b>Longest match wins</b> and <b>Backreferences</b>
          sections for more examples. See <b>regular-expressions: alternation</b>
          for more information on this topic.
        </p>
        <div class="code">
          <code>
            $ echo 'spared party parent' | sed -E 's/spa|spared/**/g'<br />
            ** party parent<br />
            $ echo 'spared party parent' | sed -E 's/spared|spa/**/g'<br />
            ** party parent<br />
            <br />
            $ # other implementations like 'perl' have left-to-right priority<br />
            $ echo 'spared party parent' | perl -pe 's/spa|spared/**/'<br />
            **red party parent
          </code>
        </div>
      </section>
      <section id="grouping">
        <h2 class="section_h">Grouping</h2>
        <p>
          Often, there are some common things among the regular expression
          alternatives. It could be common characters or qualifiers like the
          anchors. In such cases, you can group them using a pair of
          parantheses metacharacters. Similar to <code>a(b+c)d = abd+acd</code>
          in maths, you get <code>a(b|c)d = abd|acd</code> in regular expressions.
        </p>
        <div class="code">
          <code>
            $ # without grouping<br />
            $ printf 'red\nreform\nread\narrest\n' | sed -nE '/reform|rest/p'<br />
            reform<br />
            arrest<br />
            $ # with grouping<br />
            $ printf 'red\nreform\nread\narrest\n' | sed -nE '/re(form|st)/p'<br />
            reform<br />
            arrest<br />
            <br />
            $ # without grouping<br />
            $ printf 'sub par\nsapre\npart time\n' | sed -nE '/\bpar\b|\bpart\b/p'<br />
            sub par<br />
            part time<br />
            $ # taking out common anchors<br />
            $ printf 'sub par\nspare\npart time\n' | sed -nE '/\b(par|part)\b/p'<br />
            sub par<br />
            part time<br />
            $ # taking out common characters as well<br />
            $ # you'll later learn a better technique instead of using empty alternative<br />
            $ printf 'sub par\nspare\npart time\n' | sed -nE '/\bpart(|t)\b/p'<br />
            sub par<br />
            part time
          </code>
        </div>
      </section>
      <section id="metacharacters">
        <h2 class="section_h">Matching the Metacharacters</h2>
        <p>
          You have seen a few metacharacters and escape sequences that help to
          compose a regular expression. To match the metacharacters literally,
          i.e. to remove their special meaning, prefix those characters with a
          <code>\</code> character. To indicate a literal <code>\</code> character,
          use <code>\\</code>. Some of the metacharacters, like the line anchors,
          lose their special meaning when not used in their customary positions.
          If there are many metacharacters to be escaped, try to work out if the
          command can be simplified by switching between ERE and BRE.
        </p>
        <div class="code">
          <code>
            $ # line anchors aren't special away from customary positions<br />
            $ echo 'a^2 + b^2 - C*3' | sed -n '/b^2/p'<br />
            a^2 + b^2 - C*3<br />
            $ echo '$a = $b + $c' | sed -n '/$b/p'<br />
            $a = $b + $c<br />
            $ # escape line anchors to match them literally at customary positions<br />
            $ echo '$a = $b + $c' | sed 's/\$//g'<br />
            a = b + c<br />
            <br />
            $ # BRE vs ERE<br />
            $ printf '(a/b) + c\n3 + (a/b) - c\n' | sed -n '/^(a\/b)/p'<br />
            (a/b) + c<br />
            $ printf '(a/b) + c\n3 + (a/b) - c\n' | sed -nE '/^\(a\/b\)/p'<br />
            (a/b) + c
          </code>
        </div>
        <p>
          Handling the metacharacters in replacement section will be discussed in
          <b>Backreferences</b> section.
        </p>
      </section>
      <section id="deliimiters">
        <p>
          The <code>/</code> character is idiomatically used as the delimiter
          for REGEXP. But any character other than <code>\</code> and the newline
          character can be used instead. This helps to avoid or reduce the need
          for escaping delimiter characters. The syntax is simple for substitution
          and transliteration commands, just use a different character instead of
          <code>/</code>.
        </p>
        <div class="code">
          <code>
            $ # instead of this<br />
            $ echo '/home/learnbyexample/report<br />s' | sed 's/\/home\/learnbyexample\//~\//'
            ~/reports<br />
            $ # use a different delimiter<br />
            $ echo '/home/learnbyexample/report<br />s' | sed 's#/home/learnbyexample/#~/#'
            ~/reports<br />
            <br />
            $ echo 'a/b/c/d' | sed 'y/a\/d/1-4/'<br />
            1-b-c-4<br />
            $ echo 'a/b/c/d' | sed 'y,a/d,1-4,'<br />
            1-b-c-4
          </code>
        </div>
        <p>
          For address matching, syntax is a bit different, the first delimiter
          has to be escaped. For address rangers, start and end REGEXP can have
          different delimiters, as they are independent.
        </p>
        <div class="code">
          <code>
            $ printf '/foo/bar/1\n/foo/baz/1\n'<br />
            /foo/bar/1<br />
            /foo/baz/1<br />
            <br />
            $ # here ; is used as the delimiter<br />
            $ printf '/foo/bar/1\n/foo/baz/1\n' | sed -n '\;/foo/bar/;p'<br />
            /foo/bar/1
          </code>
        </div>
      </section>
      <section id="the_dot">
        <h2 class="section_h">The Dot Meta Character</h2>
        <p>
          The dot metacharacter serves as a placeholder to match any character
          (including newline character). Later you'll learn how to define your
          own custom placeholder for limited set of characters.
        </p>
        <div class="code">
          <code>
            $ # 3 character sequence starting with 'c' and ending with 't'<br />
            $ echo 'tac tin cot abc:tyz excited' | sed 's/c.t/-/g'<br />
            ta-in - ab-yz ex-ed<br />
            <br />
            $ # any character followed by 3 and again any character<br />
            $ printf '42\t35\n' | sed 's/.3.//'<br />
            42<br />
            <br />
            $ # N command is handy here to show that . matches \n as well<br />
            $ printf 'abc\nxyz\n' | sed 'N; s/c.x/ /'<br />
            ab yz
          </code>
        </div>
      </section>
    </main>
  </body>
</html>